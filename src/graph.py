import operator
from typing import TypedDict, Optional, List
import re
import os

# Import Pydantic models
from src.data_models.social_media import SocialMediaPost, SocialMediaCampaignPost, InstagramPost, FacebookPost, SocialMediaPostDraft
from src.data_models.design_spec import DesignSpecification


from dotenv import load_dotenv
from langgraph.graph import StateGraph, END

# Import agents and tools
from src.agents.strategist import StrategistAgent
from src.agents.researcher import ResearcherAgent
from src.agents.copywriter import CopywriterAgent
from src.agents.creative_director import CreativeDirectorAgent
from src.agents.critic import CriticAgent # Added import
from src.agents.fact_checker import FactCheckerAgent # NEW IMPORT
from src.agents.content_planner import ContentPlannerAgent # NEW IMPORT
from src.tools.image_generation import generate_image
from src.tools.video_generator_tool import VideoGeneratorTool # NEW IMPORT
from src.tools.generation_budget_manager import (
    can_generate,
    record_generation,
    get_budget_status,
    estimate_llm_cost,
    estimate_embedding_cost, # Added import
)
from src.config import MAX_ITERATIONS # Added import
from src.tools.html_bundler import generate_html_report, generate_pdf_report # NEW IMPORT

load_dotenv()

class AgentState(TypedDict):
    """
    Represents the state of our multi-agent workflow, extended for multi-post campaigns.
    """
    overall_campaign_goal: str # The initial, overarching campaign goal
    target_audience: str # Description of the target audience
    num_posts: int # Desired number of posts to generate

    post_objectives: List[str] # List of individual post objectives generated by ContentPlanner
    current_post_index: int # Index of the post currently being processed
    all_post_results: List[dict] # To store results of each individual post'
    overall_campaign_dir: str # NEW: The base directory for the entire multi-post campaign
    
    campaign_goal: str
    research_context: str
    marketing_content: Optional[SocialMediaPost]
    design_specs: Optional[DesignSpecification]
    generated_image_path: Optional[str] # Made optional
    generated_video_path: Optional[str] # New field for video
    campaign_dir: str
    last_action_cost: float
    cumulative_daily_spend: str
    html_report_path: Optional[str]
    pdf_report_path: Optional[str]
    reference_image_path: Optional[str]
    no_copywriting: Optional[bool]

    # New fields for refinement loop
    marketing_content_versions: List[SocialMediaPost]
    design_specs_versions: List[DesignSpecification]
    critique_feedback: str
    iteration_count: int

# --- Node Functions ---

def budget_check_node(state):
    """Checks the budget before starting the workflow."""
    if not can_generate(0): # Check if we have any budget left at all
        print("Daily budget exceeded. Halting workflow.")
        return {"last_action_cost": 0, "cumulative_daily_spend": get_budget_status()}
    
    # If no_copywriting and reference_image_path, pre-populate design_specs to trigger image generation
    if state.get("no_copywriting") and state.get("reference_image_path"):
        print("No-copywriting flag active with reference image. Skipping content generation agents.")
        # Create a dummy SocialMediaPost
        dummy_social_media_post = SocialMediaPost(
            platform="instagram", # Default platform, can be generalized
            text_content=f"Campaign for {state['campaign_goal']}. Content skipped due to no-copywriting flag.",
            image_paths=[],
            video_path=None,
            hashtags=[],
            mentions=[],
            call_to_action_text=None,
            call_to_action_url=None
        )
        # Create a DesignSpecification with the image generation prompt
        design_spec = DesignSpecification(
            overall_visual_concept=f"Image for campaign goal: {state['campaign_goal']}",
            image_prompt=f"Generate an image that fulfills the campaign goal: {state['campaign_goal']}. Focus on accurately replicating the product from the provided reference image. Negative prompts: distorted product, altered label, incorrect branding, different packaging, blurry text, cartoon, illustration, dark lighting, sad dog, no lid, no extraneous parts, no image artifacts, no unexpected elements in the product area.",
            color_palette=["#000000"], # Placeholder
            typography="Default", # Placeholder
            layout_guidance="Centered image", # Placeholder
            ml_reasoning="Skipped content generation due to no-copywriting flag."
        )
        return {
            "marketing_content": dummy_social_media_post,
            "design_specs": design_spec,
            "research_context": "Skipped research due to no-copywriting flag.",
        }
    return {}

def strategist_node(state):
    print("--- Running Strategist ---")
    input_text = state["campaign_goal"]
    result = StrategistAgent().refine_goal(input_text)
    cost = estimate_embedding_cost("models/embedding-001", input_text) # Use embedding cost
    record_generation(cost, "StrategistAgent")
    return {
        "campaign_goal": result,
        "last_action_cost": cost,
        "cumulative_daily_spend": get_budget_status(),
        "marketing_content_versions": state.get("marketing_content_versions", []), # Preserve history
        "design_specs_versions": state.get("design_specs_versions", []), # Preserve history
        "iteration_count": state.get("iteration_count", 0), # Preserve count
        "critique_feedback": state.get("critique_feedback", "") # Preserve feedback
    }

def researcher_node(state):
    print("--- Running Researcher ---")
    input_text = state["campaign_goal"]
    result = ResearcherAgent().research(input_text)
    cost = estimate_embedding_cost("models/embedding-001", input_text) # Use embedding cost
    record_generation(cost, "ResearcherAgent")
    return {
        "research_context": result,
        "last_action_cost": cost,
        "cumulative_daily_spend": get_budget_status(),
    }

def copywriter_node(state):
    print(f"--- Running Copywriter (Iteration {state['iteration_count'] + 1}) ---")
    
    feedback_context = f"\nPrevious Critique: {state['critique_feedback']}" if state["critique_feedback"] else ""
    
    # The CopywriterAgent now directly returns a SocialMediaPost Pydantic object
    social_media_post_draft: SocialMediaPostDraft = CopywriterAgent().draft_content(state["campaign_goal"], state["research_context"] + feedback_context)
    
    # Calculate cost based on the text_content of the generated post
    cost = estimate_llm_cost("gemini-pro-latest", f"Campaign Goal: {state['campaign_goal']}\nResearch Context: {state['research_context']}\nFeedback: {feedback_context}", social_media_post_draft.model_dump_json())
    record_generation(cost, "CopywriterAgent")
    
    # Append current version to history
    # Note: marketing_content_versions will temporarily hold SocialMediaPostDraft until combine_post_media_node
    marketing_content_versions = state.get("marketing_content_versions", []) + [social_media_post_draft]
    
    return {
        "marketing_content": social_media_post_draft, # Temporarily store the draft
        "marketing_content_versions": marketing_content_versions,
        "last_action_cost": cost,
        "cumulative_daily_spend": get_budget_status(),
    }

def creative_director_node(state):
    print(f"--- Running Creative Director (Iteration {state['iteration_count'] + 1}) ---")
    
    feedback_context = f"\nPrevious Critique: {state['critique_feedback']}" if state["critique_feedback"] else ""
    
    # The CreativeDirectorAgent now directly returns a DesignSpecification Pydantic object
    design_spec: DesignSpecification = CreativeDirectorAgent().generate_design_specs(
        state["campaign_goal"],
        state["research_context"] + feedback_context,
        reference_image_path=state.get("reference_image_path") # Pass reference image path
    )
    
    # Calculate cost based on the string representation of the generated design_spec
    cost = estimate_llm_cost("gemini-pro-latest", f"Campaign Goal: {state['campaign_goal']}\nResearch Context: {state['research_context']}\nFeedback: {feedback_context}", design_spec.model_dump_json())
    record_generation(cost, "CreativeDirectorAgent")
    
    # Append current version to history
    design_specs_versions = state.get("design_specs_versions", []) + [design_spec]
    
    return {
        "design_specs": design_spec,
        "design_specs_versions": design_specs_versions,
        "last_action_cost": cost,
        "cumulative_daily_spend": get_budget_status(),
    }

def critic_node(state):
    print(f"--- Running Critic (Iteration {state['iteration_count'] + 1}) ---")
    critic_agent = CriticAgent() # Instantiate CriticAgent
    fact_checker_agent = FactCheckerAgent() # Instantiate FactCheckerAgent
    
    # Ensure marketing_content and design_specs are not None before calling json()
    marketing_content_json = state["marketing_content"].model_dump_json(indent=2) if state["marketing_content"] else ""
    design_specs_json = state["design_specs"].model_dump_json(indent=2) if state["design_specs"] else ""

    input_for_critic = (
        f"Campaign Goal: {state['campaign_goal']}\n"
        f"Research Context: {state['research_context']}\n"
        f"Marketing Content:\n{marketing_content_json}\n"
        f"Design Specs:\n{design_specs_json}"
    )
    
    critique_feedback = critic_agent.critique(
        state["campaign_goal"],
        state["research_context"],
        marketing_content_json,
        design_specs_json
    )

    # Perform fact-checking and append to critique_feedback
    fact_checking_report = fact_checker_agent.check_facts(
        state["campaign_goal"],
        marketing_content_json,
        design_specs_json,
        state["research_context"]
    )

    full_feedback = f"{critique_feedback}\n\n{fact_checking_report}"
    
    cost = estimate_llm_cost("gemini-pro-latest", input_for_critic, full_feedback)
    record_generation(cost, "CriticAgent")
    
    return {
        "critique_feedback": full_feedback,
        "iteration_count": state["iteration_count"] + 1,
        "last_action_cost": cost,
        "cumulative_daily_spend": get_budget_status(),
    }

def media_generator_node(state):
    print("--- Running Media Generator ---")
    design_specs: Optional[DesignSpecification] = state["design_specs"]
    generated_image_path = None
    generated_video_path = None
    
    if not design_specs:
        print("No design specifications found. Skipping media generation.")
        return {
            "generated_image_path": None,
            "generated_video_path": None,
            "cumulative_daily_spend": get_budget_status(),
        }

    if design_specs.media_type == "image":
        if design_specs.image_prompt:
            image_prompt = design_specs.image_prompt
            print(f"--- DEBUG: Image prompt from design_specs: {image_prompt} ---")
            
            generated_image_path = generate_image(
                image_prompt, 
                state["campaign_dir"],
                reference_image_path=state.get("reference_image_path")
            )
        else:
            print("Design specs media_type is 'image' but no image_prompt provided. Skipping image generation.")
            
    elif design_specs.media_type == "video":
        if design_specs.video_script and design_specs.video_style and design_specs.video_duration_seconds and design_specs.video_assets_description:
            video_generator = VideoGeneratorTool()
            # In a real scenario, this would involve budget checks for video generation
            # For now, we'll simulate the cost or assume it's covered by LLM costs
            
            generated_video_path = video_generator.run(
                video_script=design_specs.video_script,
                video_style=design_specs.video_style,
                video_duration_seconds=design_specs.video_duration_seconds,
                video_assets_description=design_specs.video_assets_description,
                campaign_dir=state["campaign_dir"]
            )
        else:
            print("Design specs media_type is 'video' but incomplete video details provided. Skipping video generation.")
            
    else:
        print(f"Unknown media_type: {design_specs.media_type}. Skipping media generation.")

    return {
        "generated_image_path": generated_image_path,
        "generated_video_path": generated_video_path,
        "cumulative_daily_spend": get_budget_status(),
    }

def design_change_proposer_node(state):
    # This node is based on a string-based proposed_design_change
    # Now proposed_design_change is part of DesignSpecification
    design_specs: Optional[DesignSpecification] = state["design_specs"]
    if design_specs and design_specs.proposed_design_change:
        proposal = design_specs.proposed_design_change
        print(f"\n--- Design Change Proposed ---")
        print(proposal)
        return {"proposed_design_change": proposal}
    return {"proposed_design_change": None} # Return None if no proposal

def report_cost_node(state):
    print(f"--- Action Cost: ${state['last_action_cost']:.4f} ---")
    print(f"--- {state['cumulative_daily_spend']} ---")
    return {}

def final_report_node(state): # Renamed from html_bundler_node
    print("--- Finalizing Report and Saving Files ---")
    output_dir = state["campaign_dir"]

    # Save outputs to files
    # The campaign goal and research context are still saved as markdown for easy viewing
    with open(os.path.join(output_dir, "campaign_goal.md"), "w") as f:
        f.write(f"# Campaign Goal\n\n{state.get('campaign_goal', 'No goal defined.')}")
    
    with open(os.path.join(output_dir, "research_context.md"), "w") as f:
        f.write(f"# Research Context\n\n{state.get('research_context', 'No research context.')}")
        
    # Save all versions of marketing content as JSON files
    marketing_content_versions = state.get('marketing_content_versions', [])
    if marketing_content_versions:
        for i, content_version in enumerate(marketing_content_versions):
            version_filename = os.path.join(output_dir, f"marketing_content_v{i+1}.json")
            with open(version_filename, "w") as f:
                f.write(content_version.model_dump_json(indent=2)) # Save as JSON
        
        # Save the final version as a separate file
        final_marketing_content = marketing_content_versions[-1]
        final_filename = os.path.join(output_dir, "marketing_content_FINAL.json")
        with open(final_filename, "w") as f:
            f.write(final_marketing_content.model_dump_json(indent=2))
    
    # Save all versions of design specs as JSON files
    design_specs_versions = state.get('design_specs_versions', [])
    if design_specs_versions:
        for i, specs_version in enumerate(design_specs_versions):
            version_filename = os.path.join(output_dir, f"design_specs_v{i+1}.json")
            with open(version_filename, "w") as f:
                f.write(specs_version.model_dump_json(indent=2)) # Save as JSON
        
        # Save the final version as a separate file
        final_design_specs = design_specs_versions[-1]
        final_filename = os.path.join(output_dir, "design_specs_FINAL.json")
        with open(final_filename, "w") as f:
            f.write(final_design_specs.model_dump_json(indent=2))

    if state.get("generated_image_path"):
        with open(os.path.join(output_dir, "generated_image_path.txt"), "w") as f: # Save path as plain text
            f.write(state['generated_image_path'])
    elif state.get("generated_video_path"):
        with open(os.path.join(output_dir, "generated_video_path.txt"), "w") as f: # Save path as plain text
            f.write(state['generated_video_path'])

    # Now generate the HTML report using the Pydantic objects
    print("--- Generating HTML Report ---")
    html_report_path = generate_html_report(
        campaign_dir=state["campaign_dir"],
        marketing_content=state["marketing_content"],
        design_specs=state["design_specs"],
        generated_image_path=state.get("generated_image_path"),
        generated_video_path=state.get("generated_video_path")
    )
    
    # Now generate the PDF report
    pdf_report_path = None
    if html_report_path:
        pdf_filename = os.path.join(state["campaign_dir"], "report.pdf")
        pdf_report_path = generate_pdf_report(html_report_path, pdf_filename)
    
    print(f"\nCampaign output saved to: {output_dir}")
    print("\n--- Final Budget ---")
    print(state.get("cumulative_daily_spend"))

    return {
        "html_report_path": html_report_path,
        "pdf_report_path": pdf_report_path,
        "cumulative_daily_spend": get_budget_status(),
    }

# --- New node to combine post draft with media ---
def combine_post_media_node(state):
    print("--- Combining Post Content with Media ---")
    marketing_content_draft: SocialMediaPostDraft = state["marketing_content"]
    generated_image_path: Optional[str] = state["generated_image_path"]
    generated_video_path: Optional[str] = state["generated_video_path"]

    image_paths = []
    video_path = None

    if generated_image_path:
        image_paths.append(generated_image_path)
    if generated_video_path:
        video_path = generated_video_path
    
    # Create the final SocialMediaPost object
    try:
        final_social_media_post = SocialMediaPost(
            platform=marketing_content_draft.platform,
            text_content=marketing_content_draft.text_content,
            image_paths=image_paths if image_paths else None, # Pass None if empty to allow validation to catch missing media
            video_path=video_path,
            hashtags=marketing_content_draft.hashtags,
            mentions=marketing_content_draft.mentions,
            call_to_action_text=marketing_content_draft.call_to_action_text,
            call_to_action_url=marketing_content_draft.call_to_action_url,
        )
        print("Successfully combined content with media into SocialMediaPost.")
    except Exception as e:
        print(f"Error combining content with media: {e}")
        # In case of an error, return the draft and indicate failure
        # For now, we'll re-raise as it indicates a critical workflow issue
        raise e

    # Update the marketing_content in state with the final SocialMediaPost
    # Also update the versions history with the final post (replace the last draft with final)
    marketing_content_versions = state.get("marketing_content_versions", [])
    if marketing_content_versions and isinstance(marketing_content_versions[-1], SocialMediaPostDraft):
        marketing_content_versions[-1] = final_social_media_post
    elif not marketing_content_versions:
        marketing_content_versions = [final_social_media_post]
    # If it's not a draft or list is empty, something is wrong, but for now we proceed

    return {
        "marketing_content": final_social_media_post,
        "marketing_content_versions": marketing_content_versions,
    }


# --- Conditional Edges ---

def should_continue_refinement(state):
    if state["iteration_count"] >= MAX_ITERATIONS:
        print(f"Max iterations ({MAX_ITERATIONS}) reached. Ending refinement loop.")
        return "end_refinement"
    if "No further improvements needed." in state["critique_feedback"]:
        print("Critic is satisfied. Ending refinement loop.")
        return "end_refinement"
    return "refine" # Loop back for refinement

def should_generate_media_or_propose_change(state) -> str:
    design_specs: Optional[DesignSpecification] = state["design_specs"]
    if not design_specs:
        return "no_media_or_change"
    
    if design_specs.media_type == "image" and design_specs.image_prompt:
        return "generate_media"
    elif design_specs.media_type == "video" and design_specs.video_script: # Assuming video_script is key for video generation
        return "generate_media"
    elif design_specs.proposed_design_change:
        return "propose_design_change"
    else:
        return "no_media_or_change"

# --- Graph Definition ---

def create_single_post_workflow():
    workflow = StateGraph(AgentState)

    workflow.add_node("budget_check", budget_check_node)
    workflow.add_node("strategist", strategist_node)
    workflow.add_node("report_strategist_cost", report_cost_node)
    workflow.add_node("researcher", researcher_node)
    workflow.add_node("report_researcher_cost", report_cost_node)
    workflow.add_node("copywriter", copywriter_node)
    workflow.add_node("report_copywriter_cost", report_cost_node)
    workflow.add_node("creative_director", creative_director_node)
    workflow.add_node("report_creative_director_cost", report_cost_node)
    workflow.add_node("critic", critic_node) # New node
    workflow.add_node("report_critic_cost", report_cost_node) # New node
    workflow.add_node("media_generator", media_generator_node)
    workflow.add_node("report_media_cost", report_cost_node)
    workflow.add_node("combine_post_media", combine_post_media_node) # NEW NODE
    workflow.add_node("propose_design_change", design_change_proposer_node)
    workflow.add_node("final_report", final_report_node) # NEW: Final Report Node
    
    workflow.set_entry_point("budget_check")

    workflow.add_conditional_edges(
        "budget_check",
        lambda state: "skip_content_generation" if state.get("no_copywriting") else ("strategist" if can_generate(0) else "BUDGET_EXCEEDED"),
        {
            "strategist": "strategist",
            "skip_content_generation": "check_media_or_design_change", # Corrected target
            "BUDGET_EXCEEDED": END
        }
    )

    workflow.add_edge("strategist", "report_strategist_cost")
    workflow.add_edge("report_strategist_cost", "researcher")
    workflow.add_edge("researcher", "report_researcher_cost")
    
    # Initial pass for content and design
    workflow.add_edge("report_researcher_cost", "copywriter")
    workflow.add_edge("copywriter", "report_copywriter_cost")
    workflow.add_edge("report_copywriter_cost", "creative_director")
    workflow.add_edge("creative_director", "report_creative_director_cost")
    workflow.add_edge("report_creative_director_cost", "critic")
    workflow.add_edge("critic", "report_critic_cost")

    # Refinement loop
    workflow.add_conditional_edges(
        "report_critic_cost",
        should_continue_refinement,
        {
            "refine": "copywriter", # Loop back for refinement
            "end_refinement": "check_media_or_design_change", # Proceed to media/design change check
        }
    )

    # New conditional gateway after refinement
    workflow.add_node("check_media_or_design_change", lambda state: state) # Dummy node to branch

    
    workflow.add_conditional_edges(
        "check_media_or_design_change",
        should_generate_media_or_propose_change,
        {
            "generate_media": "media_generator",
            "propose_design_change": "propose_design_change",
            "no_media_or_change": "final_report", # New path for bundler
        },
    )

    workflow.add_edge("media_generator", "report_media_cost")
    workflow.add_edge("report_media_cost", "combine_post_media") # NEW EDGE
    workflow.add_edge("combine_post_media", "final_report") # NEW EDGE
    workflow.add_edge("propose_design_change", END)
    workflow.add_edge("final_report", END) # Final report is the final step

    return workflow.compile()

def create_multi_post_workflow():
    single_post_subgraph = create_single_post_workflow()

    multi_post_workflow = StateGraph(AgentState)

    multi_post_workflow.add_node("plan_posts", plan_posts_node)
    multi_post_workflow.add_node("prepare_single_post_state", prepare_single_post_state_node)
    multi_post_workflow.add_node("run_single_post_workflow", lambda state: single_post_subgraph.invoke(state))
    multi_post_workflow.add_node("collect_single_post_results", collect_single_post_results_node)
    multi_post_workflow.add_node("final_multi_post_report", final_multi_post_report_node)

    multi_post_workflow.set_entry_point("plan_posts")
    multi_post_workflow.add_edge("plan_posts", "prepare_single_post_state")
    multi_post_workflow.add_edge("prepare_single_post_state", "run_single_post_workflow")
    multi_post_workflow.add_edge("run_single_post_workflow", "collect_single_post_results")

    multi_post_workflow.add_conditional_edges(
        "collect_single_post_results",
        should_continue_posts,
        {
            "continue": "prepare_single_post_state",
            "end": "final_multi_post_report"
        }
    )
    multi_post_workflow.add_edge("final_multi_post_report", END)

    return multi_post_workflow.compile()

if __name__ == "__main__":
    # Example usage for single post workflow
    # app = create_single_post_workflow()
    
    # initial_objective = "Create a social media post for our new 'Simply RawÂ®' beef recipe, with an-eye-catching image, and make sure it meets our brand standards. Also ensure the copy is very concise."
    # initial_state = {
    #     "campaign_goal": initial_objective,
    #     "campaign_dir": "CAMPAIGNS/test_campaign_refinement",
    #     "last_action_cost": 0,
    #     "cumulative_daily_spend": get_budget_status(),
    #     "marketing_content_versions": [],
    #     "design_specs_versions": [],
    #     "critique_feedback": "",
    #     "iteration_count": 0,
    # }
    
    # final_state = app.invoke(initial_state)
    
    # print("\n--- Final Campaign Summary (Single Post) ---")
    # print(f"Refined Campaign Goal: {final_state.get('campaign_goal')}")
    # if final_state.get('marketing_content_versions'):
    #     print(f"Marketing Content (All Versions): {final_state['marketing_content_versions']}")
    #     print(f"Marketing Content (Final Version): {final_state['marketing_content_versions'][-1]}")
    # if final_state.get('design_specs_versions'):
    #     print(f"Design Specs (All Versions): {final_state['design_specs_versions']}")
    #     print(f"Design Specs (Final Version): {final_state['design_specs_versions'][-1]}")
    # if final_state.get("generated_image_path"):
    #     print(f"Generated Image Path: {final_state.get('generated_image_path')}")
    # if final_state.get("proposed_design_change"):
    #     print(f"Proposed Design Change: {final_state.get('proposed_design_change')}")
    # print(f"\n--- Final Budget ---")
    # print(final_state.get("cumulative_daily_spend"))

    # Example usage for multi-post workflow
    multi_post_app = create_multi_post_workflow()

    overall_objective = "Create a multi-post social media campaign emphasizing why Simply Raw is great for beginners."
    target_audience_desc = "New pet owners or those new to raw food, looking for affordable and convenient alternatives to frozen/fresh raw food."
    num_posts_to_generate = 2 # Testing with a small number first

    multi_post_campaign_dir = "CAMPAIGNS/multi_post_simply_raw_for_beginners"
    os.makedirs(multi_post_campaign_dir, exist_ok=True)

    initial_multi_post_state = {
        "overall_campaign_goal": overall_objective,
        "target_audience": target_audience_desc,
        "num_posts": num_posts_to_generate,
        "campaign_dir": multi_post_campaign_dir, # This is the overall campaign directory
        "overall_campaign_dir": multi_post_campaign_dir, # Also pass this for final report
        "post_objectives": [], # Will be populated by plan_posts_node
        "current_post_index": 0, # Initialized to 0
        "all_post_results": [], # Initialized as empty list
        "cumulative_daily_spend": get_budget_status(), # Initial budget status
        "last_action_cost": 0,
        
        # Default values for single_post_workflow, will be overwritten by prepare_single_post_state_node
        "campaign_goal": "", 
        "research_context": "",
        "marketing_content": None,
        "design_specs": None,
        "generated_image_path": None,
        "generated_video_path": None,
        "html_report_path": None,
        "pdf_report_path": None,
        "reference_image_path": None,
        "no_copywriting": False,
        "marketing_content_versions": [],
        "design_specs_versions": [],
        "critique_feedback": "",
        "iteration_count": 0,
    }

    final_multi_post_state = multi_post_app.invoke(initial_multi_post_state)

    print("\n--- Final Multi-Post Campaign Summary ---")
    print(f"Overall Campaign Goal: {final_multi_post_state.get('overall_campaign_goal')}")
    print(f"Total Posts Generated: {len(final_multi_post_state.get('all_post_results', []))}")
    for i, post_result in enumerate(final_multi_post_state.get('all_post_results', [])):
        print(f"\n--- Post {i+1} ---")
        print(f"Objective: {post_result.get('post_objective')}")
        print(f"Final Content (excerpt): {post_result.get('marketing_content_final', '')[:100]}...")
        print(f"Image Path: {post_result.get('generated_image_path')}")
        print(f"Report HTML: {post_result.get('html_report_path')}")
        print(f"Report PDF: {post_result.get('pdf_report_path')}")
    print(f"\nSummary Report: {final_multi_post_state.get('final_multi_post_report_path')}")
    print(f"\n--- Final Cumulative Budget Spend ---")
    print(state.get("cumulative_daily_spend"))
